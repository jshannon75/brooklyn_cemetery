---
title: "Brooklyn tree processing"
format: html
editor: visual
editor_options: 
  chunk_output_type: console
---

```{r setup}
library(tidyverse)
library(googlesheets4)
```

Read in tree data

```{r}
trees<-read_sheet("https://docs.google.com/spreadsheets/d/12j85I59vPPfEu3TFYQTNhvsBPkmz34i71xFuHSTXlsc/edit?usp=sharing",sheet=2) %>%
  mutate(end_x=0,end_y=0) %>%
  filter(is.na(Start_Point)==F) %>%
  rename(start_x=Start_X_m,
         start_y=Start_Y_m,
         azimuth=Azimuth_deg,
         distance=Distance_m)
```

```{r}
library(tidyverse)

# Function to calculate new point from distance and azimuth
calculate_point <- function(x, y, distance, azimuth) {
  # azimuth in degrees (0° = North, 90° = East, clockwise)
  azimuth_rad <- azimuth * pi / 180
  
  # Calculate new coordinates (UTM: x = easting, y = northing)
  tibble(
    x = x + distance * sin(azimuth_rad),
    y = y + distance * cos(azimuth_rad)
  )
}

# Read the CSV file
data <- trees

# Initialize points tibble with the known starting point
points <- tibble(
  point_id = unique(c(data$Start_Point, data$End_Point)),
  x = NA_real_,
  y = NA_real_
) %>%
  mutate(
    x = if_else(point_id == 1, 832042.44, x),
    y = if_else(point_id == 1, 3761488.83, y)
  )

# Iterate until all points are calculated
max_iterations <- 100
for (iteration in 1:max_iterations) {
  points_before <- points
  
  # Forward calculation: start point known -> calculate end point
  forward <- data %>%
    left_join(points, by = c("Start_Point" = "point_id")) %>%
    rename(start_x = x, start_y = y) %>%
    left_join(points, by = c("End_Point" = "point_id")) %>%
    rename(end_x = x, end_y = y) %>%
    filter(!is.na(start_x), is.na(end_x)) %>%
    mutate(calc = map2(start_x, start_y, ~calculate_point(.x, .y, Distance_m, Azimuth_deg))) %>%
    unnest(calc) %>%
    select(point_id = End_Point, x, y)
  
  # Backward calculation: end point known -> calculate start point
  backward <- data %>%
    left_join(points, by = c("Start_Point" = "point_id")) %>%
    rename(start_x = x, start_y = y) %>%
    left_join(points, by = c("End_Point" = "point_id")) %>%
    rename(end_x = x, end_y = y) %>%
    filter(is.na(start_x), !is.na(end_x)) %>%
    mutate(
      reverse_azimuth = (Azimuth_deg + 180) %% 360,
      calc = map2(end_x, end_y, ~calculate_point(.x, .y, Distance_m, reverse_azimuth))
    ) %>%
    unnest(calc) %>%
    select(point_id = Start_Point, x, y)
  
  # Update points with newly calculated coordinates
  new_points <- bind_rows(forward, backward)
  
  if (nrow(new_points) > 0) {
    points <- points %>%
      rows_update(new_points, by = "point_id", unmatched = "ignore")
  }
  
  # Stop if no changes were made
  if (identical(points, points_before)) {
    break
  }
}

# Create complete dataset with all coordinates
data_with_coords <- data %>%
  left_join(points, by = c("Start_Point" = "point_id")) %>%
  rename(Calc_Start_X = x, Calc_Start_Y = y) %>%
  left_join(points, by = c("End_Point" = "point_id")) %>%
  rename(Calc_End_X = x, Calc_End_Y = y)

# Display results
cat("Calculated Point Coordinates:\n")
print(points, n = Inf)

cat("\nComplete Data with Calculated Coordinates:\n")
print(data_with_coords, n = Inf)

# Save results
write_csv(points, "calculated_points.csv")
write_csv(data_with_coords, "data_with_coordinates.csv")
```

